%{
    #include "expr_ast.h"
    void addSeqStmt(ASTNode* seq, ASTNode* node)
    {
        SeqStatement* s = (SeqStatement*)seq;
        while (s->stmt2)
        {
            s = (SeqStatement*)s->stmt2;
        }
        SeqStatement *nuevo = new SeqStatement();
        nuevo->stmt1 = node;
        s->stmt2 = nuevo;
    }
%}

%decls %{
    #include <unordered_map>
    #include <vector>
    #include <iostream>
    using namespace std;
    using VariablesMap = unordered_map<string, int>;
    using StdString = std::string;
    class ASTNode;

    void addSeqStmt(ASTNode* seq, ASTNode* node);



%}

%option lang="C++"
%node ASTNode %abstract %typedef

%node Expr ASTNode %abstract 

%node BinaryExpr Expr %abstract = {
    ASTNode *expr1;
    ASTNode *expr2;
}

%node AddExpr BinaryExpr
%node SubExpr BinaryExpr
%node MulExpr BinaryExpr
%node DivExpr BinaryExpr

%node Number Expr = {
    int value;
}

%node Ident Expr = {
    string name;
}

%node Statement ASTNode %abstract %typedef

%node SeqStatement Statement ={
    %nocreate ASTNode *stmt1;
    %nocreate ASTNode *stmt2;
}

%node IfStatement Statement = {
    ASTNode* cond;
    ASTNode *stmtsTrue;
    ASTNode *stmtsFalse;
}

%node PrintStatement Statement = {
    ASTNode* expr;
}

%node AssignStatement Statement = {
    ASTNode* lhs;
    ASTNode* rhs;
}

%operation %virtual StdString toString(ASTNode *this,VariablesMap vars)
%operation %virtual StdString getOper(BinaryExpr *this)

getOper(AddExpr) { return "+"; }
getOper(SubExpr) { return "-"; }
getOper(MulExpr) { return "*"; }
getOper(DivExpr) { return "/"; }

toString(BinaryExpr) {
    std::string s1 = expr1->toString(vars);
    std::string s2 = expr2->toString(vars);

    return "(" + s1 + ")" + getOper() + "(" + s2 + ")";
}

toString(Number) {
    return std::to_string(value);
}

toString(Ident) {
    return name;
}

toString(AssignStatement) {
    return lhs->toString(vars) + "=" + rhs->toString(vars);
}

toString(PrintStatement) {
    return "print " + expr->toString(vars);
}

toString(IfStatement) {
    return "if (" + cond->toString(vars) + ") {\n"
           + stmtsTrue->toString(vars) + "\n} else {\n"
           + stmtsFalse->toString(vars) + "\n}";
}

toString(SeqStatement) {
    return stmt1->toString(vars) + "\n" + stmt2->toString(vars);
}